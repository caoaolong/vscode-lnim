<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src {{cspSource}} 'unsafe-inline' https:; font-src {{cspSource}} https:; script-src {{cspSource}} 'unsafe-inline';">
    <title>LNIM Chat</title>
    <link rel="stylesheet" href="https://unpkg.com/@vscode/codicons/dist/codicon.css">
    <style>
        body {
            font-family: var(--vscode-font-family);
            color: var(--vscode-foreground);
            background-color: var(--vscode-editor-background);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        
        /* Header Styles */
        #header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background-color: var(--vscode-sideBar-background);
            border-bottom: 1px solid var(--vscode-widget-border);
        }
        #header h3 {
            margin: 0;
            font-size: 14px;
        }
        .icon-btn {
            cursor: pointer;
            color: var(--vscode-icon-foreground);
            background: none;
            border: none;
            padding: 2px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .icon-btn:hover {
            color: var(--vscode-foreground);
        }
        #header-right {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .icon-btn .codicon {
            font-size: 16px;
        }

        /* Chat Box Styles */
        #chat-box {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        /* Message Styles */
        .message-container {
            display: flex;
            flex-direction: column;
            max-width: 85%;
            margin-bottom: 8px;
        }
        .message-container.self {
            align-self: flex-end;
            align-items: flex-end;
        }
        .message-container.other {
            align-self: flex-start;
            align-items: flex-start;
        }
        
        .nickname {
            font-size: 11px;
            color: var(--vscode-descriptionForeground);
            margin-bottom: 2px;
            padding: 0 4px;
        }
        
        .message {
            padding: 8px 12px;
            border-radius: 8px;
            word-wrap: break-word;
            position: relative;
            line-height: 1.4;
        }
        .message-container.self .message {
            background-color: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
            border-bottom-right-radius: 2px;
        }
        .message-container.other .message {
            background-color: var(--vscode-list-hoverBackground);
            color: var(--vscode-foreground);
            border-bottom-left-radius: 2px;
        }

        /* Timestamp Styles */
        .timestamp {
            align-self: center;
            font-size: 11px;
            color: var(--vscode-descriptionForeground);
            background-color: var(--vscode-textBlockQuote-background);
            padding: 2px 8px;
            border-radius: 10px;
            margin: 10px 0;
        }

        /* Input Area Styles */
        #input-container {
            flex-shrink: 0;
            padding: 10px;
            border-top: 1px solid var(--vscode-widget-border);
            background-color: var(--vscode-editor-background);
            display: flex;
            flex-direction: column;
            position: relative;
        }
        #message-input {
            width: 100%;
            min-height: 40px;
            max-height: 150px;
            padding: 8px;
            box-sizing: border-box;
            background-color: var(--vscode-input-background);
            color: var(--vscode-input-foreground);
            border: 1px solid var(--vscode-input-border);
            border-radius: 4px;
            overflow-y: auto;
            outline: none;
            white-space: pre-wrap;
            line-height: 1.4;
        }
        #message-input:empty:before {
            content: attr(placeholder);
            color: var(--vscode-input-placeholderForeground);
        }
        #mention-suggest {
            position: absolute;
            left: 10px;
            bottom: 56px;
            width: calc(100% - 20px);
            max-height: 240px;
            overflow-y: auto;
            background: var(--vscode-editorWidget-background, var(--vscode-editor-background));
            border: 1px solid var(--vscode-widget-border);
            border-radius: 4px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
            display: none;
            z-index: 120;
        }
        .mention-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            font-size: 12px;
            color: var(--vscode-foreground);
            cursor: pointer;
        }
        .mention-item .codicon {
            font-size: 14px;
            color: var(--vscode-icon-foreground);
        }
        .mention-item:hover,
        .mention-item.active {
            background: var(--vscode-list-hoverBackground);
        }
        .mention-item .type {
            margin-left: auto;
            color: var(--vscode-descriptionForeground);
            font-size: 11px;
        }
        .mention-tag {
            display: inline-flex;
            align-items: center;
            gap: 0.35em;
            padding: 0 0.45em;
            margin: 0 0.2em;
            height: 1.2em;
            border-radius: 2px;
            background: transparent;
            border: 1px solid var(--vscode-widget-border);
            color: var(--vscode-foreground);
            user-select: none;
            cursor: pointer;
            vertical-align: middle;
            transform: translateY(-0.05em);
        }
        .mention-tag .codicon {
            font-size: 0.9em;
            color: var(--vscode-icon-foreground);
            line-height: 1;
        }
        .mention-tag .label {
            font-size: 1em;
            line-height: 1;
            display: inline-block;
        }
        .mention-tag .close {
            cursor: pointer;
            color: var(--vscode-descriptionForeground);
            line-height: 1;
            align-self: center;
        }
        .mention-tag .close:hover {
            color: var(--vscode-errorForeground);
        }
        .mention-tag[data-type="contact"] { border-color: var(--vscode-charts-green, #89d185); color: var(--vscode-charts-green, #89d185); }
        .mention-tag[data-type="folder"] { border-color: var(--vscode-charts-yellow, #cca700); color: var(--vscode-charts-yellow, #cca700); }
        .mention-tag[data-type="file"] { border-color: var(--vscode-charts-blue, #3794ff); color: var(--vscode-charts-blue, #3794ff); }
        .mention-tag[data-type="image"] { border-color: var(--vscode-charts-purple, #b180d7); color: var(--vscode-charts-purple, #b180d7); }
        .mention-tag[data-type="contact"] .codicon { color: inherit; }
        .mention-tag[data-type="folder"] .codicon { color: inherit; }
        .mention-tag[data-type="file"] .codicon { color: inherit; }
        .mention-tag[data-type="image"] .codicon { color: inherit; }

        /* Settings Overlay Styles */
        #settings-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: flex-start;
            z-index: 100;
            padding-top: 50px;
        }
        #settings-panel {
            background-color: var(--vscode-editor-background);
            padding: 20px;
            border: 1px solid var(--vscode-widget-border);
            border-radius: 5px;
            width: 80%;
            max-width: 300px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            font-weight: bold;
        }
        .form-group input,
        .form-group select {
            width: 100%;
            padding: 6px;
            background-color: var(--vscode-input-background);
            color: var(--vscode-input-foreground);
            border: 1px solid var(--vscode-input-border);
            box-sizing: border-box;
        }
        .button-group {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        button {
            padding: 6px 12px;
            border: none;
            cursor: pointer;
            border-radius: 2px;
        }
        #save-btn {
            background-color: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
        }
        #cancel-btn {
            background-color: var(--vscode-button-secondaryBackground);
            color: var(--vscode-button-secondaryForeground);
        }
        /* Contacts Overlay Styles */
        #contacts-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
            padding: 16px;
            box-sizing: border-box;
        }
        #contacts-panel {
            background-color: var(--vscode-editorWidget-background, var(--vscode-editor-background));
            padding: 16px;
            border: 1px solid var(--vscode-widget-border);
            border-radius: 5px;
            width: 92%;
            max-width: 520px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
        }
        #contacts-panel h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            border-bottom: 1px solid var(--vscode-widget-border);
            padding-bottom: 6px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            line-height: 24px;
        }
        #contact-form {
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 8px;
            margin-bottom: 12px;
        }
        #contact-form input {
            padding: 6px;
            background-color: var(--vscode-input-background);
            color: var(--vscode-input-foreground);
            border: 1px solid var(--vscode-input-border);
            box-sizing: border-box;
        }
        #add-contact-btn {
            background-color: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
            border: none;
            padding: 6px 10px;
            cursor: pointer;
            white-space: nowrap;
        }
        table.contacts {
            width: 100%;
            border-collapse: collapse;
        }
        table.contacts th,
        table.contacts td {
            border: 1px solid var(--vscode-widget-border);
            padding: 6px 8px;
            font-size: 12px;
        }
        table.contacts th {
            background: var(--vscode-sideBar-background);
            text-align: left;
        }
        .text-btn {
            background: none;
            border: none;
            padding: 0;
            cursor: pointer;
            color: var(--vscode-textLink-foreground);
            font-size: 12px;
            margin-right: 8px;
        }
        .text-btn:hover {
            text-decoration: underline;
            color: var(--vscode-textLink-activeForeground, var(--vscode-textLink-foreground));
        }
        .status-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-left: 6px;
        }
        .status-dot.online {
            background-color: #4CAF50; /* Green */
        }
        .status-dot.offline {
            background-color: #9E9E9E; /* Grey */
        }
    </style>
</head>
<body>
    <div id="header">
        <h3>LNIM Chat</h3>
        <div id="header-right">
            <button class="icon-btn" id="contacts-btn" title="添加联系人">
                <span class="codicon codicon-account"></span>
            </button>
            <button class="icon-btn" id="settings-btn" title="Settings">
                <span class="codicon codicon-gear"></span>
            </button>
        </div>
    </div>

    <div id="contacts-overlay">
        <div id="contacts-panel">
            <h3>
                <span>联系人</span>
                <div style="display:flex;align-items:center;gap:6px;">
                    <button class="icon-btn" id="scan-contacts-btn" title="扫描局域网联系人">
                        <span class="codicon codicon-search"></span>
                    </button>
                    <button class="icon-btn" id="close-contacts-btn" title="关闭">
                        <span class="codicon codicon-close"></span>
                    </button>
                </div>
            </h3>
            <div id="contact-form">
                <input type="text" id="contact-ip" placeholder="主机地址 (IP:端口)">
                <input type="text" id="contact-username" placeholder="用户名">
                <button id="add-contact-btn">
									<span class="codicon codicon-add"></span>
								</button>
            </div>
            <table class="contacts">
                <thead>
                    <tr>
                        <th>主机地址</th>
                        <th>用户名</th>
                        <th>操作</th>
                    </tr>
                </thead>
                <tbody id="contacts-tbody"></tbody>
            </table>
        </div>
    </div>

    <div id="chat-box"></div>

    <div id="input-container">
        <div id="message-input" contenteditable="true" placeholder="Type a message..."></div>
        <div id="mention-suggest"></div>
        <div id="input-toolbar" style="margin-top: 4px;">
            <button id="image-btn" class="icon-btn" title="插入图片">
                <span class="codicon codicon-file-media"></span>
            </button>
        </div>
    </div>

    <div id="settings-overlay">
        <div id="settings-panel">
            <h3>Settings</h3>
            <div class="form-group">
                <label for="nickname">Nickname</label>
                <input type="text" id="nickname" placeholder="Enter your nickname">
            </div>
            <div class="form-group">
                <label for="ip-address">IP Address</label>
                <select id="ip-address"></select>
            </div>
            <div class="form-group">
                <label for="port">Port</label>
                <input type="number" id="port" min="1" max="65535" placeholder="18080">
            </div>
            <div class="button-group">
                <button id="cancel-btn">取消</button>
                <button id="save-btn">保存</button>
            </div>
        </div>
    </div>

    <script>
        const vscode = acquireVsCodeApi();
        const chatBox = document.getElementById('chat-box');
        const input = document.getElementById('message-input');
        const settingsOverlay = document.getElementById('settings-overlay');
        const nicknameInput = document.getElementById('nickname');
        const ipInput = document.getElementById('ip-address');
        const portInput = document.getElementById('port');
        const contactsOverlay = document.getElementById('contacts-overlay');
        const contactIpInput = document.getElementById('contact-ip');
        const contactUsernameInput = document.getElementById('contact-username');
        const contactsTbody = document.getElementById('contacts-tbody');
        const mentionSuggest = document.getElementById('mention-suggest');
        const imageBtn = document.getElementById('image-btn');
        const scanContactsBtn = document.getElementById('scan-contacts-btn');
        const closeContactsBtn = document.getElementById('close-contacts-btn');

        let currentUserSettings = {
            nickname: 'User',
            ip: '',
            port: 18080
        };
        let lastMessageTime = 0;
        let contacts = [];
        let allContacts = [];
        let filesCache = [];
        let foldersCache = [];
        let mentionActive = false;
        let mentionQuery = '';
        let mentionItems = [];
        let mentionIndex = -1;
        let mentionTrigger = '';
        let contextMenuTarget = null;
        let currentBrowsePath = '';
        let directoryItems = [];
        let contactStatusMap = {};
        let contactsStatusRequested = false;
        let localIps = [];

        // --- Event Listeners ---

        if (scanContactsBtn) {
            scanContactsBtn.addEventListener('click', () => {
                vscode.postMessage({
                    type: 'scanContacts'
                });
            });
        }

        if (closeContactsBtn) {
            closeContactsBtn.addEventListener('click', () => {
                contactsOverlay.style.display = 'none';
            });
        }

        input.addEventListener('keydown', (e) => {
            if (mentionActive) {
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    if (mentionItems.length) {
                        mentionIndex = (mentionIndex + 1) % mentionItems.length;
                        renderMention();
                    }
                    return;
                }
                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    if (mentionItems.length) {
                        mentionIndex = (mentionIndex - 1 + mentionItems.length) % mentionItems.length;
                        renderMention();
                    }
                    return;
                }
                if (e.key === 'ArrowRight') {
                    if (mentionTrigger === '#' && mentionItems.length && mentionIndex >= 0) {
                        const item = mentionItems[mentionIndex];
                        if (item.type === 'folder') {
                            e.preventDefault();
                            // Enter folder
                            currentBrowsePath = item.value; // Full relative path
                            mentionQuery = ''; // Reset query to show all in folder
                            vscode.postMessage({ type: 'getDirectoryContent', path: currentBrowsePath });
                            // We might want to update input text to show path? 
                            // User request: "Display subdirectories, recursively".
                            // Usually this means the popup updates.
                            // If we update input text, it might interfere with "back".
                            // But let's keep input text as is (just #...) until selection.
                            // OR does user expect input to become #path/to/folder/?
                            // If I type #src, select src, press right, I see contents of src.
                            // If I then select a file, it inserts #src/file.
                            // This implies we don't necessarily update input text until final selection, 
                            // OR we do update it. 
                            // If we don't update input text, the filter uses "src" against "fileInSrc"? No.
                            // If I entered "src", filter matched "src".
                            // If I enter folder, I should probably clear the query part of input or update it?
                            // Let's assume for now we just browse in popup.
                            return;
                        }
                    }
                }
                if (e.key === 'Enter') {
                    e.preventDefault();
                    if (mentionIndex >= 0 && mentionIndex < mentionItems.length) {
                        applyMention(mentionItems[mentionIndex]);
                        closeMention();
                        return;
                    }
                }
                if (e.key === 'Escape') {
                    e.preventDefault();
                    closeMention();
                    return;
                }
            }
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                const message = buildMessageText().trim();
                if (message) {
                    sendMessage(message);
                    input.innerHTML = '';
                    closeMention();
                }
                return;
            }
            if (e.key === '@' || e.key === '#') {
                setTimeout(() => {
                    openMentionIfNeeded();
                }, 0);
            }
            if (e.key === 'Backspace') {
                const sel = window.getSelection();
                if (sel && sel.rangeCount) {
                    const range = sel.getRangeAt(0);
                    if (range.collapsed) {
                        let container = range.startContainer;
                        let offset = range.startOffset;
                        if (container.nodeType === Node.TEXT_NODE) {
                            if (offset === 0) {
                                const prev = container.previousSibling;
                                if (prev && prev.nodeType === Node.ELEMENT_NODE && prev.classList && prev.classList.contains('mention-tag')) {
                                    e.preventDefault();
                                    prev.remove();
                                    return;
                                }
                            }
                        } else if (container.nodeType === Node.ELEMENT_NODE) {
                            const el = container;
                            const prev = el.childNodes[offset - 1];
                            if (prev && prev.nodeType === Node.ELEMENT_NODE && prev.classList && prev.classList.contains('mention-tag')) {
                                e.preventDefault();
                                prev.remove();
                                return;
                            }
                        }
                    }
                }
            }
        });
        input.addEventListener('input', () => {
            if (!mentionActive) {
                openMentionIfNeeded();
                return;
            }
            const q = getCurrentMentionQuery();
            if (q === null) {
                closeMention();
            } else {
                mentionQuery = q;
                filterMention();
            }
        });

        imageBtn.addEventListener('click', () => {
            vscode.postMessage({ type: 'selectImage' });
        });

        // Drag and Drop
        input.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
        });
        input.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                const file = e.dataTransfer.files[0];
                let path = file.path;
                if (path) {
                    let type = 'file';
                    if (!file.type && !path.includes('.')) type = 'folder';
                    if (file.type && file.type.startsWith('image/')) type = 'image';
                    const label = file.name || path.split(/[\/\\]/).pop();
                    const item = { type, value: path, label: label };
                    insertTagAtCursor(item);
                }
                return;
            }
            const text = e.dataTransfer.getData('text/plain');
            if (text && (text.includes('/') || text.includes('\\'))) {
                const label = text.split(/[\/\\]/).pop();
                const type = /\.(png|jpg|jpeg|gif|webp|bmp)$/i.test(text) ? 'image' : 'file';
                const item = { type, value: text, label: label };
                insertTagAtCursor(item);
            }
        });

        function insertTagAtCursor(item) {
             const tag = createMentionTag(item, { closable: true, source: 'input' });
             input.focus();
             const sel = window.getSelection();
             if (sel.rangeCount > 0) {
                 const range = sel.getRangeAt(0);
                 range.deleteContents();
                 range.insertNode(tag);
                 range.collapse(false);
                 const space = document.createTextNode(' ');
                 range.insertNode(space);
                 range.collapse(false);
                 sel.removeAllRanges();
                 sel.addRange(range);
             } else {
                 input.appendChild(tag);
                 input.appendChild(document.createTextNode(' '));
                 placeCaretAtEnd(input);
             }
        }

        document.getElementById('settings-btn').addEventListener('click', () => {
            nicknameInput.value = currentUserSettings.nickname;
            const port = currentUserSettings.port && currentUserSettings.port > 0 && currentUserSettings.port <= 65535
                ? currentUserSettings.port
                : 18080;
            if (portInput) {
                portInput.value = String(port);
            }
            updateIpSelectOptions();
            settingsOverlay.style.display = 'flex';
        });
        document.getElementById('contacts-btn').addEventListener('click', () => {
            contactIpInput.value = '';
            contactUsernameInput.value = '';
            contactsOverlay.style.display = 'flex';
            contactStatusMap = {};
            contactsStatusRequested = false;
            vscode.postMessage({ type: 'getContacts' });
        });

        document.getElementById('cancel-btn').addEventListener('click', () => {
            settingsOverlay.style.display = 'none';
        });

        document.getElementById('save-btn').addEventListener('click', () => {
            let port = 18080;
            if (portInput) {
                const v = portInput.value.trim();
                if (v) {
                    const n = parseInt(v, 10);
                    if (n > 0 && n <= 65535) {
                        port = n;
                    }
                }
            }
            const newSettings = {
                nickname: nicknameInput.value.trim() || 'User',
                ip: ipInput.value.trim(),
                port
            };
            vscode.postMessage({ type: 'saveSettings', settings: newSettings });
            currentUserSettings = newSettings;
            settingsOverlay.style.display = 'none';
        });
        document.getElementById('add-contact-btn').addEventListener('click', () => {
            const host = contactIpInput.value.trim();
            const username = contactUsernameInput.value.trim();
            if (!host || !username) return;
            const parts = host.split(':');
            if (parts.length !== 2) {
                window.alert('主机地址格式必须为 IP:端口');
                return;
            }
            const ip = parts[0].trim();
            const portStr = parts[1].trim();
            const port = parseInt(portStr, 10);
            if (!ip || !portStr || isNaN(port) || port <= 0 || port > 65535) {
                window.alert('主机地址格式必须为 IP:有效端口(1-65535)');
                return;
            }
            vscode.postMessage({ type: 'addContact', contact: { ip, port, username }});
            contactIpInput.value = '';
            contactUsernameInput.value = '';
        });

        // --- Message Handling ---

        window.addEventListener('message', event => {
            const message = event.data;
            switch (message.type) {
                case 'updateSettings':
                    currentUserSettings = message.settings;
                    break;
                case 'settingsSaved':
                    currentUserSettings = message.settings;
                    break;
                case 'localIps':
                    localIps = Array.isArray(message.ips) ? message.ips : [];
                    updateIpSelectOptions();
                    break;
                case 'updateContacts':
                    contacts = message.contacts || [];
                    allContacts = contacts.slice();
                    if (mentionActive) filterMention();
                    contactsStatusRequested = false;
                    renderContacts();
                    break;
                case 'contactsSaved':
                    contacts = message.contacts || [];
                    allContacts = contacts.slice();
                    if (mentionActive) filterMention();
                    contactsStatusRequested = false;
                    renderContacts();
                    break;
                case 'contactsStatus':
                    contactStatusMap = {};
                    (message.statuses || []).forEach(s => {
                        const key = (s.ip || '') + '|' + (s.username || '');
                        contactStatusMap[key] = s.online ? 'online' : 'offline';
                    });
                    renderContacts();
                    break;
                case 'filesAndFolders':
                    filesCache = message.files || [];
                    foldersCache = message.folders || [];
                    // We might not use this for # anymore if we use directoryContent
                    break;
                case 'directoryContent': {
                    const pathPrefix = message.path ? (message.path + '/') : '';
                    directoryItems = [];
                    // Add ".." if not root?
                    if (message.path) {
                        // We could add a parent entry, but user didn't explicitly ask for it.
                        // But standard navigation usually has it.
                        // For now, let's stick to showing folders/files.
                        // To go back, maybe backspace handles it if we sync input?
                        // Actually, if we are browsing, we are just changing the list content.
                    }
                    (message.folders || []).forEach(f => {
                        directoryItems.push({ type: 'folder', label: f, value: pathPrefix + f });
                    });
                    (message.files || []).forEach(f => {
                        directoryItems.push({ type: 'file', label: f, value: pathPrefix + f });
                    });
                    
                    if (mentionActive && mentionTrigger === '#') {
                        filterMention();
                    }
                    break;
                }
                case 'imageSelected':
                    if (message.path) {
                        insertTagAtCursor({ 
                            type: 'image', 
                            value: message.path, 
                            label: message.label || message.path.split('/').pop() 
                        });
                    }
                    break;
                case 'receiveMessage':
                    const sender = message.from || {};
                    addMessage({
                        text: message.message,
                        isSelf: false,
                        nickname: sender.nickname || 'Unknown',
                        timestamp: message.timestamp
                    });
                    break;
            }
        });

        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (settingsOverlay.style.display === 'flex') {
                    settingsOverlay.style.display = 'none';
                }
                if (contactsOverlay.style.display === 'flex') {
                    contactsOverlay.style.display = 'none';
                }
                if (mentionActive) {
                    closeMention();
                }
            }
        });

        function sendMessage(text) {
            const now = Date.now();
            checkAndAddTimestamp(now);
            
            addMessage({
                text: text,
                isSelf: true,
                nickname: currentUserSettings.nickname,
                timestamp: now
            });

            vscode.postMessage({ 
                type: 'sendMessage', 
                value: text,
                timestamp: now,
                nickname: currentUserSettings.nickname
            });
            
            lastMessageTime = now;
        }

        function checkAndAddTimestamp(currentTimestamp) {
            if (currentTimestamp - lastMessageTime > 10 * 60 * 1000) {
                const date = new Date(currentTimestamp);
                const timeString = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                
                const div = document.createElement('div');
                div.className = 'timestamp';
                div.textContent = timeString;
                chatBox.appendChild(div);
            }
        }

        function addMessage({ text, isSelf, nickname }) {
            const container = document.createElement('div');
            container.className = 'message-container' + (isSelf ? ' self' : ' other');
            
            const nicknameDiv = document.createElement('div');
            nicknameDiv.className = 'nickname';
            nicknameDiv.textContent = nickname;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message';
            renderMessageContent(messageDiv, text);
            
            container.appendChild(nicknameDiv);
            container.appendChild(messageDiv);
            
            chatBox.appendChild(container);
            chatBox.scrollTop = chatBox.scrollHeight;
        }
        function renderMessageContent(container, text) {
            container.innerHTML = '';
            const parts = text.split(/(\s+)/);
            parts.forEach((part) => {
                if (!part) return;
                if (/^\s+$/.test(part)) {
                    container.appendChild(document.createTextNode(part));
                    return;
                }
                if (part[0] === '@' && part.length > 1) {
                    let name = part.slice(1);
                    let suffix = '';
                    const m = name.match(/^([^\s.,;:!?]+)([.,;:!?]*)$/);
                    if (m) {
                        name = m[1];
                        suffix = m[2];
                    }
                    const item = resolveMentionItem(name);
                    const tag = createMentionTag(item, { closable: false, source: 'message' });
                    container.appendChild(tag);
                    if (suffix) {
                        container.appendChild(document.createTextNode(suffix));
                    }
                } else {
                    container.appendChild(document.createTextNode(part));
                }
            });
        }
        function openMentionIfNeeded() {
            const q = getCurrentMentionQuery();
            if (q === null) {
                closeMention();
                return;
            }
            if (!mentionActive) {
                mentionActive = true;
                mentionIndex = -1;
                if (mentionTrigger === '@') {
                    vscode.postMessage({ type: 'getContacts' });
                } else if (mentionTrigger === '#') {
                    currentBrowsePath = '';
                    vscode.postMessage({ type: 'getDirectoryContent', path: '' });
                }
            }
            mentionQuery = q;
            filterMention();
        }
        function closeMention() {
            mentionActive = false;
            mentionQuery = '';
            mentionItems = [];
            mentionIndex = -1;
            mentionTrigger = '';
            currentBrowsePath = '';
            mentionSuggest.style.display = 'none';
            mentionSuggest.innerHTML = '';
        }
        function getCurrentMentionQuery() {
            const sel = window.getSelection();
            if (!sel || sel.rangeCount === 0) return null;
            const text = input.innerText;
            const caret = getCaretCharacterOffsetWithin(input);
            if (caret === null) return null;
            const before = text.slice(0, caret);
            
            const at = before.lastIndexOf('@');
            const hash = before.lastIndexOf('#');
            
            let index = -1;
            let trigger = '';
            
            if (at > hash) {
                index = at;
                trigger = '@';
            } else {
                index = hash;
                trigger = '#';
            }
            
            if (index === -1) return null;
            if (index > 0) {
                const prev = before.charAt(index - 1);
                if (!/\s/.test(prev)) return null;
            }
            
            const query = before.slice(index + 1);
            if (/\s/.test(query)) return null;
            
            mentionTrigger = trigger;
            return query;
        }
        function filterMention() {
            const q = mentionQuery.toLowerCase();
            let sourceItems = [];
            
            if (mentionTrigger === '@') {
                sourceItems = (allContacts || []).map(c => ({
                    type: 'contact',
                    label: c.username,
                    value: c.username,
                    detail: c.ip
                }));
            } else if (mentionTrigger === '#') {
                sourceItems = directoryItems;
            }
            
            mentionItems = sourceItems.filter(it => !q || it.label.toLowerCase().includes(q));
            if (mentionItems.length > 0 && mentionIndex === -1) mentionIndex = 0;
            if (mentionIndex >= mentionItems.length) mentionIndex = 0;
            renderMention();
        }
        function renderMention() {
            if (!mentionActive || mentionItems.length === 0) {
                mentionSuggest.style.display = 'none';
                mentionSuggest.innerHTML = '';
                return;
            }
            mentionSuggest.style.display = 'block';
            mentionSuggest.innerHTML = '';
            
            mentionItems.slice(0, 50).forEach((it, idx) => {
                const div = document.createElement('div');
                div.className = 'mention-item' + (idx === mentionIndex ? ' active' : '');
                const icon = document.createElement('span');
                icon.className = 'codicon ' + (it.type === 'contact' ? 'codicon-account' : it.type === 'folder' ? 'codicon-folder' : it.type === 'image' ? 'codicon-file-media' : 'codicon-file');
                const label = document.createElement('span');
                label.textContent = it.label;
                div.appendChild(icon);
                div.appendChild(label);
                
                if (mentionTrigger === '#' && it.type === 'folder') {
                    const arrow = document.createElement('span');
                    arrow.className = 'codicon codicon-chevron-right';
                    arrow.style.marginLeft = 'auto';
                    arrow.style.fontSize = '12px';
                    div.appendChild(arrow);
                }
                
                if (it.detail) {
                    const t = document.createElement('span');
                    t.className = 'type';
                    t.textContent = it.detail;
                    div.appendChild(t);
                } 
                
                div.addEventListener('mouseenter', () => {
                    mentionIndex = idx;
                    renderMention();
                });
                div.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                });
                div.addEventListener('click', () => {
                    applyMention(mentionItems[idx]);
                    closeMention();
                });
                mentionSuggest.appendChild(div);
            });
        }
        function applyMention(item) {
            const sel = window.getSelection();
            if (!sel || sel.rangeCount === 0) return;
            let range = sel.getRangeAt(0);
            let container = range.startContainer;
            if (container.nodeType !== Node.TEXT_NODE) {
                const placeholder = document.createTextNode('');
                range.insertNode(placeholder);
                range.setStart(placeholder, 0);
                range.setEnd(placeholder, 0);
                container = placeholder;
            }
            const textNode = container;
            const beforeText = textNode.data.slice(0, range.startOffset);
            const afterText = textNode.data.slice(range.startOffset);
            
            const atIndex = beforeText.lastIndexOf('@');
            const hashIndex = beforeText.lastIndexOf('#');
            const index = Math.max(atIndex, hashIndex);
            
            if (index === -1) return;
            
            const head = beforeText.slice(0, index);
            textNode.data = head;
            
            const tag = createMentionTag(item, { closable: true, source: 'input' });
            
            const space = document.createTextNode(' ');
            const tail = document.createTextNode(afterText);
            
            if (textNode.nextSibling) {
                textNode.parentNode.insertBefore(tag, textNode.nextSibling);
            } else {
                textNode.parentNode.appendChild(tag);
            }
            // Insert space after tag
            tag.parentNode.insertBefore(space, tag.nextSibling);
            // Insert tail after space
            space.parentNode.insertBefore(tail, space.nextSibling);
            
            const newRange = document.createRange();
            newRange.setStart(tail, 0);
            newRange.collapse(true);
            sel.removeAllRanges();
            sel.addRange(newRange);
            input.focus();
        }

        function createMentionTag(item, opts) {
            const span = document.createElement('span');
            span.className = 'mention-tag';
            if (opts && opts.source === 'input') {
                span.setAttribute('contenteditable', 'false');
            }
            span.dataset.type = item.type;
            span.dataset.value = item.value;
            // Determine trigger based on type for consistency in buildMessageText
            const trigger = item.type === 'contact' ? '@' : '#';
            span.dataset.trigger = trigger;
            
            const icon = document.createElement('span');
            icon.className = 'codicon ' + (item.type === 'contact' ? 'codicon-account' : item.type === 'folder' ? 'codicon-folder' : item.type === 'image' ? 'codicon-file-media' : 'codicon-file');
            
            const label = document.createElement('span');
            label.className = 'label';
            // Figure 1 shows @Builder but just database_provider.ts (no #)
            label.textContent = (item.type === 'contact' ? '@' : '') + item.label;
            
            span.appendChild(icon);
            span.appendChild(label);
            if (opts && opts.closable) {
                const close = document.createElement('span');
                close.className = 'close codicon codicon-close';
                close.title = '移除';
                close.addEventListener('click', (e) => {
                    e.stopPropagation();
                    span.remove();
                });
                span.appendChild(close);
            }
            span.addEventListener('click', (e) => {
                e.stopPropagation();
                vscode.postMessage({
                    type: 'tagClicked',
                    item: { type: item.type, value: item.value, label: item.label }
                });
                if (opts && opts.source === 'input') {
                    input.focus();
                }
            });
            return span;
        }
        function resolveMentionItem(val, trigger) {
            // trigger hint helps disambiguate if needed
            if (!trigger || trigger === '@') {
                const c = (allContacts || []).find(x => x.username === val);
                if (c) return { type: 'contact', value: c.username, label: c.username, detail: c.ip };
            }
            if (!trigger || trigger === '#') {
                // val could be full path or basename?
                // In renderMessageContent we extract name. 
                // If the message raw text is #path/to/file.ts, then name is path/to/file.ts
                // If it is #file.ts, name is file.ts
                // Let's check filesCache for suffix match or full match
                const fldr = (foldersCache || []).find(x => x === val || x.endsWith('/' + val));
                if (fldr) return { type: 'folder', value: fldr, label: fldr.split('/').pop() };
                const file = (filesCache || []).find(x => x === val || x.endsWith('/' + val));
                if (file) return { type: 'file', value: file, label: file.split('/').pop() };
                
                // Fallback guessing for when cache is empty (recursive browse mode)
                // Check if looks like image
                if (/\.(png|jpg|jpeg|gif|webp|bmp)$/i.test(val)) {
                    return { type: 'image', value: val, label: val.split(/[\/\\]/).pop() };
                }
                if (val.includes('/') || val.includes('\\')) {
                     const isFile = /\.[^/\\]+$/.test(val);
                     return { type: isFile ? 'file' : 'folder', value: val, label: val.split(/[\/\\]/).pop() };
                }
                if (/\.[^/\\]+$/.test(val)) {
                     return { type: 'file', value: val, label: val };
                }
            }
            // Fallback
            return { type: 'mention', value: val, label: val };
        }
        function buildMessageText() {
            let s = '';
            input.childNodes.forEach((node) => {
                if (node.nodeType === Node.TEXT_NODE) {
                    s += node.nodeValue;
                } else if (node.nodeType === Node.ELEMENT_NODE) {
                    const el = node;
                    if (el.classList && el.classList.contains('mention-tag')) {
                        const v = el.dataset.value || '';
                        const trigger = el.dataset.trigger || '@';
                        s += trigger + v + ' ';
                    } else {
                        s += el.textContent;
                    }
                }
            });
            return s;
        }
        function getCaretCharacterOffsetWithin(element) {
            let caretOffset = 0;
            const sel = window.getSelection();
            if (!sel || sel.rangeCount === 0) return null;
            const range = sel.getRangeAt(0);
            const preRange = range.cloneRange();
            preRange.selectNodeContents(element);
            preRange.setEnd(range.endContainer, range.endOffset);
            caretOffset = preRange.toString().length;
            return caretOffset;
        }
        function placeCaretAtEnd(el) {
            el.focus();
            const range = document.createRange();
            range.selectNodeContents(el);
            range.collapse(false);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
        }
        function renderContacts() {
            contactsTbody.innerHTML = '';
            contacts.forEach((c) => {
                const tr = document.createElement('tr');
                const tdHost = document.createElement('td');
                const tdUser = document.createElement('td');
                const tdOps = document.createElement('td');
                const portText = c.port && c.port > 0 && c.port <= 65535 ? String(c.port) : '';
                tdHost.textContent = c.ip ? (portText ? (c.ip + ':' + portText) : c.ip) : '';
                
                // Username + Status Dot
                const nameSpan = document.createElement('span');
                nameSpan.textContent = c.username;
                tdUser.appendChild(nameSpan);

                const key = (c.ip || '') + '|' + String(c.port || '') + '|' + (c.username || '');
                const status = contactStatusMap[key];
                
                if (status === 'online' || status === 'offline') {
                    const dot = document.createElement('span');
                    dot.className = 'status-dot ' + status;
                    dot.title = status === 'online' ? '在线' : '离线';
                    tdUser.appendChild(dot);
                }

                const checkBtn = document.createElement('button');
                checkBtn.className = 'text-btn';
                checkBtn.textContent = '检测';
                checkBtn.addEventListener('click', () => {
                    vscode.postMessage({ type: 'checkContactLink', contact: c });
                });
                const delBtn = document.createElement('button');
                delBtn.className = 'text-btn';
                delBtn.textContent = '删除';
                delBtn.addEventListener('click', () => {
                    vscode.postMessage({ type: 'deleteContact', contact: c });
                });
                tdOps.appendChild(checkBtn);
                tdOps.appendChild(delBtn);
                tr.appendChild(tdHost);
                tr.appendChild(tdUser);
                tr.appendChild(tdOps);
                contactsTbody.appendChild(tr);
            });
            if (contactsOverlay.style.display === 'flex' && !contactsStatusRequested && contacts.length > 0) {
                contactsStatusRequested = true;
                requestContactsOnlineStatus(contacts);
            }
        }
        function updateIpSelectOptions() {
            if (!ipInput) {
                return;
            }
            const current = (currentUserSettings && currentUserSettings.ip) || ipInput.value || '';
            ipInput.innerHTML = '';
            const placeholder = document.createElement('option');
            placeholder.value = '';
            placeholder.textContent = localIps.length ? '请选择本机 IP 地址' : '无可用 IP 地址';
            ipInput.appendChild(placeholder);
            localIps.forEach((addr) => {
                const opt = document.createElement('option');
                opt.value = addr;
                opt.textContent = addr;
                ipInput.appendChild(opt);
            });
            if (current) {
                let found = false;
                for (let i = 0; i < ipInput.options.length; i++) {
                    if (ipInput.options[i].value === current) {
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    const opt = document.createElement('option');
                    opt.value = current;
                    opt.textContent = current;
                    ipInput.appendChild(opt);
                }
                ipInput.value = current;
            } else {
                ipInput.value = '';
            }
        }
        function requestContactsOnlineStatus(list) {
            const payload = list.map(c => ({
                ip: c.ip,
                port: c.port,
                username: c.username
            }));
            vscode.postMessage({ type: 'getContactsStatus', contacts: payload });
        }

        // --- Initialization ---
        
        // Request initial settings
        vscode.postMessage({ type: 'getSettings' });
        vscode.postMessage({ type: 'getLocalIps' });

    </script>
</body>
</html>
