# VSCode-LNIM 通信机制详细文档

## 目录

1. [系统架构概述](#系统架构概述)
2. [通信协议](#通信协议)
3. [消息类型定义](#消息类型定义)
4. [重试机制](#重试机制)
5. [文件传输流程](#文件传输流程)
6. [补发机制](#补发机制)
7. [会话管理](#会话管理)
8. [错误处理](#错误处理)
9. [性能优化](#性能优化)
10. [安全性考虑](#安全性考虑)

---

## 系统架构概述

### 核心组件

```
┌─────────────────────────────────────────────────────────────┐
│                      VSCode Extension                        │
├─────────────────────────────────────────────────────────────┤
│  ChatViewProvider (UI 控制器)                                │
│    ├─ ChatMessageService (消息服务)                          │
│    │   ├─ MessageRetryManager (重试管理器)                   │
│    │   └─ UDP Server (UDP 服务器)                            │
│    ├─ ChatFileService (文件服务)                             │
│    │   ├─ 接收会话管理                                       │
│    │   └─ 持久化存储                                         │
│    ├─ ChatMessageManager (消息历史管理)                      │
│    └─ ChatContactManager (联系人管理)                        │
└─────────────────────────────────────────────────────────────┘
                            ↕ UDP
┌─────────────────────────────────────────────────────────────┐
│                      Test Client / Peer                      │
│  (相同的协议实现)                                            │
└─────────────────────────────────────────────────────────────┘
```

### 技术栈

- **传输协议**：UDP（用户数据报协议）
- **消息格式**：JSON
- **文件分块**：1024 字节/块
- **重试策略**：指数退避（配置可调）
- **持久化**：文件系统（JSON格式）

---

## 通信协议

### 基础协议

**传输层**：UDP
- 端口：默认 18080（可配置）
- 地址：IPv4
- MTU：建议 < 1400 字节（避免分片）

**应用层**：自定义协议
- 格式：JSON
- 编码：UTF-8
- 二进制数据：Base64 编码或 Buffer

### 消息基础结构

```typescript
interface ChatMessage {
  // 消息类型
  type: "chat" | "file" | "link" | "chunk" | "chunk_resend_request" | "transfer_complete";
  
  // 发送方标识（Base64 编码）
  from: string;
  
  // 时间戳（毫秒）
  timestamp: number;
  
  // 消息唯一标识（UUID v4）
  id: string;
  
  // 是否为回复消息
  reply: boolean;
  
  // 是否为请求消息
  request: boolean;
  
  // 消息内容（根据类型不同）
  value?: string;
  
  // 目标地址列表（仅用于 chat 类型）
  target?: string[];
  
  // 附件文件列表（仅用于 chat 类型）
  files?: string[];
  
  // 文件块数据（仅用于 chunk 类型）
  chunk?: ChatFileChunk;
  
  // 缺失块列表（仅用于 chunk_resend_request 类型）
  missingChunks?: number[];
  
  // 会话ID（用于关联传输）
  sessionId?: string;
}
```

### 发送方标识格式

```typescript
// 原始格式
const rawId = `${username}-${ip}:${port}`;

// Base64 编码
const encodedId = Buffer.from(rawId, 'utf-8').toString('base64');

// 示例
// 原始: "Alice-192.168.1.100:18080"
// 编码: "QWxpY2UtMTkyLjE2OC4xLjEwMDoxODA4MA=="
```

---

## 消息类型定义

### 1. LINK 消息（链接探测）

**用途**：发现和验证对等节点

**请求消息**：
```json
{
  "type": "link",
  "from": "QWxpY2UtMTkyLjE2OC4xLjEwMDoxODA4MA==",
  "timestamp": 1705382400000,
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "reply": false,
  "request": true
}
```

**回复消息**：
```json
{
  "type": "link",
  "from": "Qm9iLTE5Mi4xNjguMS4yMDA6MTgwODA=",
  "timestamp": 1705382401000,
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "reply": true,
  "request": false
}
```

**流程**：
```
Client A                          Client B
   │                                 │
   ├─────── LINK (request) ────────>│
   │         id=xxx                  │
   │                                 │
   │<──────── LINK (reply) ──────────┤
   │         id=xxx                  │
   │                                 │
```

### 2. CHAT 消息（文本消息）

**用途**：发送文本消息或文件引用

**请求消息**：
```json
{
  "type": "chat",
  "from": "QWxpY2UtMTkyLjE2OC4xLjEwMDoxODA4MA==",
  "timestamp": 1705382400000,
  "id": "660e8400-e29b-41d4-a716-446655440001",
  "reply": false,
  "request": true,
  "value": "Hello, World!",
  "target": ["192.168.1.200:18080"]
}
```

**文件引用格式**：
```json
{
  "value": "这是一个文件 {#/path/to/file.txt}"
}
```

**回复消息**：
```json
{
  "type": "chat",
  "from": "Qm9iLTE5Mi4xNjguMS4yMDA6MTgwODA=",
  "timestamp": 1705382401000,
  "id": "660e8400-e29b-41d4-a716-446655440001",
  "reply": true,
  "request": false,
  "value": ""
}
```

### 3. FILE 消息（文件传输请求）

**用途**：请求发送文件

**请求消息**：
```json
{
  "type": "file",
  "from": "QWxpY2UtMTkyLjE2OC4xLjEwMDoxODA4MA==",
  "timestamp": 1705382400000,
  "id": "770e8400-e29b-41d4-a716-446655440002",
  "reply": false,
  "request": true,
  "value": "/path/to/file.txt"
}
```

**回复消息**：
```json
{
  "type": "file",
  "from": "Qm9iLTE5Mi4xNjguMS4yMDA6MTgwODA=",
  "timestamp": 1705382401000,
  "id": "770e8400-e29b-41d4-a716-446655440002",
  "reply": true,
  "request": false,
  "value": "/path/to/file.txt"
}
```

### 4. CHUNK 消息（文件块）

**用途**：传输文件数据块

**数据结构**：
```typescript
interface ChatFileChunk {
  index: number;      // 块索引（从0开始）
  size: number;       // 实际字节数
  data: Buffer;       // 数据内容
  finish: boolean;    // 是否为最后一块
  total?: number;     // 总块数
}
```

**请求消息**（发送数据块）：
```json
{
  "type": "chunk",
  "from": "Qm9iLTE5Mi4xNjguMS4yMDA6MTgwODA=",
  "timestamp": 1705382402000,
  "id": "880e8400-e29b-41d4-a716-446655440003",
  "reply": false,
  "request": true,
  "value": "/path/to/file.txt",
  "sessionId": "192.168.1.200_18080_/path/to/file.txt_1705382400000",
  "chunk": {
    "index": 0,
    "size": 1024,
    "data": { "type": "Buffer", "data": [0x48, 0x65, ...] },
    "finish": false,
    "total": 100
  }
}
```

**回复消息**：
```json
{
  "type": "chunk",
  "from": "QWxpY2UtMTkyLjE2OC4xLjEwMDoxODA4MA==",
  "timestamp": 1705382402500,
  "id": "880e8400-e29b-41d4-a716-446655440003",
  "reply": true,
  "request": false,
  "value": "/path/to/file.txt"
}
```

### 5. CHUNK_RESEND_REQUEST 消息（补发请求）

**用途**：请求重新发送缺失的文件块

**请求消息**：
```json
{
  "type": "chunk_resend_request",
  "from": "QWxpY2UtMTkyLjE2OC4xLjEwMDoxODA4MA==",
  "timestamp": 1705382500000,
  "id": "990e8400-e29b-41d4-a716-446655440004",
  "reply": false,
  "request": true,
  "sessionId": "192.168.1.200_18080_/path/to/file.txt_1705382400000",
  "value": "/path/to/file.txt",
  "missingChunks": [5, 17, 23, 45]
}
```

**回复消息**：
```json
{
  "type": "chunk_resend_request",
  "from": "Qm9iLTE5Mi4xNjguMS4yMDA6MTgwODA=",
  "timestamp": 1705382500500,
  "id": "990e8400-e29b-41d4-a716-446655440004",
  "reply": true,
  "request": false
}
```

### 6. TRANSFER_COMPLETE 消息（传输完成）

**用途**：通知发送方文件已完整接收

**请求消息**：
```json
{
  "type": "transfer_complete",
  "from": "QWxpY2UtMTkyLjE2OC4xLjEwMDoxODA4MA==",
  "timestamp": 1705382600000,
  "id": "aa0e8400-e29b-41d4-a716-446655440005",
  "reply": false,
  "request": true,
  "sessionId": "192.168.1.200_18080_/path/to/file.txt_1705382400000",
  "value": "/path/to/file.txt"
}
```

**回复消息**：
```json
{
  "type": "transfer_complete",
  "from": "Qm9iLTE5Mi4xNjguMS4yMDA6MTgwODA=",
  "timestamp": 1705382600500,
  "id": "aa0e8400-e29b-41d4-a716-446655440005",
  "reply": true,
  "request": false
}
```

---

## 重试机制

### MessageRetryManager 架构

```
┌─────────────────────────────────────────────────────┐
│          MessageRetryManager                        │
├─────────────────────────────────────────────────────┤
│  pendingMessages: Map<string, PendingMessage>      │
│                                                      │
│  sendWithRetry()                                    │
│    ├─ 生成 UUID                                     │
│    ├─ 发送消息                                      │
│    ├─ 启动定时器                                    │
│    └─ 存入待确认队列                                │
│                                                      │
│  markAsReceived()                                   │
│    ├─ 清除定时器                                    │
│    └─ 从队列移除                                    │
│                                                      │
│  retryMessage()                                     │
│    ├─ 检查重试次数                                  │
│    ├─ 重新发送                                      │
│    └─ 重置定时器                                    │
└─────────────────────────────────────────────────────┘
```

### 待确认消息结构

```typescript
interface PendingMessage {
  message: ChatMessage;      // 原始消息
  targetIp: string;          // 目标IP
  targetPort: number;        // 目标端口
  timer: NodeJS.Timeout;     // 重试定时器
  retryCount: number;        // 已重试次数
}
```

### 重试策略

**配置参数**：
```typescript
const retryInterval = 5000;    // 重试间隔：5秒
const maxRetries = -1;         // 最大重试次数：-1表示无限重试
```

**重试流程**：
```
发送消息 ──┬──> 等待回复（5秒）
          │
          ├──> 收到回复 ──> 停止重试 ──> 成功
          │
          └──> 超时 ──> 重试次数+1 ──> 重新发送 ──> 循环
                              │
                              └──> 达到最大次数 ──> 放弃
```

**示例代码**：
```typescript
// 发送需要确认的消息
const messageId = retryManager.sendWithRetry(
  {
    type: "chat",
    from: getSelfId(),
    timestamp: Date.now(),
    request: true,
    value: "Hello"
  },
  "192.168.1.200",
  18080
);

// 收到回复时标记
if (msg.reply && msg.id) {
  retryManager.markAsReceived(msg.id);
}
```

### 回复消息处理

**重要特性**：回复消息使用原始消息的ID
```typescript
// 发送回复（不需要重试）
retryManager.sendReply(
  originalMessageId,  // 使用请求消息的ID
  {
    type: "chat",
    from: getSelfId(),
    timestamp: Date.now(),
    request: false
  },
  remoteIp,
  remotePort
);
```

**ID匹配机制**：
```
Client A                          Client B
   │                                 │
   ├─── 消息 (id=abc) ──────────────>│
   │                                 │
   │<─── 回复 (id=abc) ──────────────┤
   │                                 │
   └─ markAsReceived(abc)            │
```

---

## 文件传输流程

### 完整传输流程图

```
发送方 (Client A)                     接收方 (Client B)
     │                                      │
     │                                      │
[1]  │─── FILE 请求 ──────────────────────>│
     │     id=file-req                     │
     │                                      │
[2]  │<──── FILE 回复 ─────────────────────┤
     │     id=file-req                     │
     │                                      │
     │  创建发送会话                        │  创建接收文件
     │  sessionId=sess-123                 │  fd=open(file, 'w')
     │  fd=open(file, 'r')                 │  接收会话 sess-123
     │                                      │
[3]  │─── CHUNK[0] ────────────────────────>│
     │     id=chunk-0                      │
     │     sessionId=sess-123              │  写入块 0
     │                                      │
[4]  │<──── CHUNK 回复 ─────────────────────┤
     │     id=chunk-0                      │
     │                                      │
[5]  │─── CHUNK[1] ────────────────────────>│
     │─── CHUNK[2] ────────────────────────>│
     │─── CHUNK[3] ────────────────────────>│
     │     ...                             │
     │                                      │
[6]  │─── CHUNK[99] (finish=true) ─────────>│
     │                                      │
     │                                      │  检查完整性
     │                                      │  发现缺失: [17, 45]
     │                                      │
[7]  │<─ CHUNK_RESEND_REQUEST ─────────────┤
     │   missingChunks=[17, 45]            │
     │   sessionId=sess-123                │
     │                                      │
[8]  │─── CHUNK_RESEND_REQUEST 回复 ───────>│
     │                                      │
     │  读取缺失块                          │
     │                                      │
[9]  │─── CHUNK[17] ───────────────────────>│
     │─── CHUNK[45] ───────────────────────>│
     │                                      │
     │                                      │  再次检查完整性
     │                                      │  所有块已接收
     │                                      │
[10] │<─── TRANSFER_COMPLETE ──────────────┤
     │     sessionId=sess-123              │
     │                                      │
[11] │─── TRANSFER_COMPLETE 回复 ──────────>│
     │                                      │
     │  关闭文件句柄                        │  关闭文件句柄
     │  清理会话 sess-123                  │  删除持久化数据
     │                                      │  打开文件
     │                                      │
```

### 阶段详解

#### [1-2] 文件传输握手

**目的**：确认双方准备就绪

**发送方行为**：
- 用户选择文件
- 发送 FILE 请求消息
- 等待确认

**接收方行为**：
- 收到 FILE 请求
- 检查磁盘空间
- 询问用户是否接收/覆盖
- 发送 FILE 回复

#### [3-5] 块传输阶段

**发送方行为**：
```typescript
// 创建发送会话
const sessionId = `${ip}_${port}_${filePath}_${Date.now()}`;
const fd = fs.openSync(filePath, 'r');
fileSendSessions.set(sessionId, {
  filePath, fd, chunkCount, 
  sentChunks: new Set(),
  targetIp, targetPort,
  lastActivityTime: Date.now()
});

// 分块发送
for (let i = 0; i < chunkCount; i++) {
  const buffer = Buffer.alloc(1024);
  const nbytes = fs.readSync(fd, buffer, 0, 1024, i * 1024);
  
  sendWithRetry({
    type: "chunk",
    sessionId,
    chunk: {
      index: i,
      size: nbytes,
      data: buffer.subarray(0, nbytes),
      finish: i === chunkCount - 1,
      total: chunkCount
    }
  });
}

// 不关闭 fd，等待传输完成确认
```

**接收方行为**：
```typescript
// 创建接收会话
const session = {
  fd: fs.openSync(filePath, 'w'),
  receivedChunks: new Set<number>(),
  totalChunks: chunk.total,
  sessionId,
  lastActivityTime: Date.now()
};

// 接收块
const buffer = Buffer.from(chunk.data);
fs.writeSync(session.fd, buffer, 0, chunk.size, chunk.index * 1024);
session.receivedChunks.add(chunk.index);
session.lastActivityTime = Date.now();

// 每10块保存一次进度
if (session.receivedChunks.size % 10 === 0) {
  savePersistenceData(session);
}

// 发送确认回复
sendReply(messageId, { type: "chunk" });
```

#### [6-9] 完整性检查与补发

**接收方检查逻辑**：
```typescript
if (chunk.finish) {
  const missingChunks = [];
  for (let i = 0; i < totalChunks; i++) {
    if (!receivedChunks.has(i)) {
      missingChunks.push(i);
    }
  }
  
  if (missingChunks.length > 0 && resendAttempts < 3) {
    // 请求补发
    sendResendRequest(sessionId, missingChunks);
    resendAttempts++;
    return; // 不关闭文件，等待补发
  } else if (missingChunks.length > 0) {
    // 失败：达到最大重试次数
    showError("传输失败");
    cleanup();
  } else {
    // 成功：所有块都收到
    sendTransferComplete(sessionId);
    cleanup();
    openFile();
  }
}
```

**发送方补发逻辑**：
```typescript
function handleResendRequest(sessionId, missingChunks) {
  const session = fileSendSessions.get(sessionId);
  if (!session) return;
  
  session.lastActivityTime = Date.now();
  
  for (const index of missingChunks) {
    const buffer = Buffer.alloc(1024);
    const nbytes = fs.readSync(
      session.fd, 
      buffer, 
      0, 
      1024, 
      index * 1024
    );
    
    sendWithRetry({
      type: "chunk",
      sessionId,
      chunk: {
        index,
        size: nbytes,
        data: buffer.subarray(0, nbytes),
        finish: index === session.chunkCount - 1,
        total: session.chunkCount
      }
    });
  }
}
```

#### [10-11] 传输完成确认

**接收方行为**：
```typescript
// 所有块已接收
sendTransferComplete(sessionId, filePath);
deletePersistenceData(sessionId);
fs.closeSync(fd);
openFileInEditor(filePath);
```

**发送方行为**：
```typescript
function handleTransferComplete(sessionId) {
  const session = fileSendSessions.get(sessionId);
  if (session) {
    fs.closeSync(session.fd);
    fileSendSessions.delete(sessionId);
    showSuccess("文件发送完成");
  }
}
```

---

## 补发机制

### 触发条件

1. **接收完最后一块时检测到缺失**
2. **未达到最大重试次数（3次）**
3. **发送会话仍然有效**

### 补发请求格式

```json
{
  "type": "chunk_resend_request",
  "sessionId": "192.168.1.200_18080_file.txt_1705382400000",
  "missingChunks": [5, 17, 23, 45, 67, 89],
  "value": "/path/to/file.txt"
}
```

### 补发流程时序图

```
接收方                              发送方
   │                                   │
   │  收到所有块（包括 finish=true）   │
   │  检测缺失：[17, 45]               │
   │                                   │
   ├─ CHUNK_RESEND_REQUEST ──────────>│
   │   missingChunks=[17,45]          │
   │                                   │
   │                                   │  收到补发请求
   │                                   │  更新活动时间
   │                                   │  从文件读取块 17
   │                                   │
   │<───── CHUNK[17] ──────────────────┤
   │                                   │
   │  收到块 17                         │  从文件读取块 45
   │  写入文件                         │
   │  发送确认                         │
   │                                   │
   │<───── CHUNK[45] ──────────────────┤
   │                                   │
   │  收到块 45                         │
   │  写入文件                         │
   │  发送确认                         │
   │                                   │
   │  再次检查完整性                   │
   │  所有块已接收！                   │
   │                                   │
   ├─ TRANSFER_COMPLETE ──────────────>│
   │                                   │
```

### 补发限制

**最大补发尝试次数**：3次
**理由**：
- 避免无限循环
- 网络持续不稳定时及时失败
- 给用户明确的反馈

**失败处理**：
```typescript
if (resendAttempts >= 3 && missingChunks.length > 0) {
  console.error(`传输失败！仍缺失 ${missingChunks.length} 个块`);
  vscode.window.showErrorMessage(
    `文件传输失败！缺失 ${missingChunks.length} 个数据块`
  );
  deletePersistenceData(sessionId);
  cleanup();
}
```

---

## 会话管理

### 发送会话（FileSendSession）

**数据结构**：
```typescript
interface FileSendSession {
  filePath: string;           // 文件路径
  fd: number;                 // 文件描述符
  chunkCount: number;         // 总块数
  sentChunks: Set<number>;    // 已发送的块索引
  targetIp: string;           // 目标IP
  targetPort: number;         // 目标端口
  lastActivityTime: number;   // 最后活动时间
  createdTime: number;        // 创建时间
}
```

**生命周期**：
```
创建 ──> 发送块 ──> 等待完成确认 ──> 清理
  │         │              │            │
  │         └─ 补发块 ─────┘            │
  │                                     │
  └──────────── 超时 ────────────────────┘
```

**存储**：
```typescript
private fileSendSessions = new Map<string, FileSendSession>();
```

**会话ID格式**：
```
${targetIp}_${targetPort}_${filePath}_${timestamp}
```

### 接收会话（ActiveDownload）

**数据结构**：
```typescript
interface ActiveDownload {
  resolve: () => void;                    // 完成回调
  report: (progress) => void;             // 进度报告
  lastPercentage: number;                 // 上次进度百分比
  receivedChunks: Set<number>;            // 已接收块索引
  totalChunks: number;                    // 总块数
  sessionId: string;                      // 会话ID
  senderIp: string;                       // 发送方IP
  senderPort: number;                     // 发送方端口
  resendAttempts: number;                 // 补发尝试次数
  lastActivityTime: number;               // 最后活动时间
  cancelled: boolean;                     // 是否已取消
  filePath: string;                       // 本地文件路径
  originalFileName: string;               // 原始文件名
  fileSize: number;                       // 估算文件大小
}
```

**生命周期**：
```
创建 ──> 接收块 ──> 检查完整性 ──> 清理
  │         │            │            │
  │         │            ├─ 请求补发 ─┤
  │         │            │            │
  │         └─── 用户取消 ────────────>│
  │                                    │
  └────────────── 超时 ────────────────┘
```

**存储**：
```typescript
private activeDownloads = new Map<string, ActiveDownload>();
```

### 超时管理

**发送会话超时**：
```typescript
// 基础：5分钟，每MB加1分钟，最多30分钟
const timeoutMs = Math.min(
  5 * 60 * 1000 + estimatedSizeMB * 60 * 1000,
  30 * 60 * 1000
);
```

**接收会话超时**：
```typescript
// 基础：60秒，每MB加30秒，最多30分钟
const timeoutMs = Math.min(
  60000 + estimatedSizeMB * 30000,
  30 * 60 * 1000
);
```

**检查间隔**：30秒

**超时处理**：
```typescript
private checkSessionTimeouts() {
  const now = Date.now();
  
  for (const [key, session] of sessions.entries()) {
    const idleTime = now - session.lastActivityTime;
    
    if (idleTime > timeoutMs) {
      console.warn(`会话超时: ${key}`);
      cleanup(key);
      notifyUser("传输超时");
    }
  }
}
```

### 活动时间更新

**接收方**：
- 收到每个 chunk 时更新
- 发送补发请求时更新

**发送方**：
- 创建会话时初始化
- 收到补发请求时更新
- 收到传输完成确认时（然后清理）

---

## 错误处理

### 错误类型与处理策略

#### 1. 网络错误

**UDP 发送失败**：
```typescript
udpServer.send(buf, port, ip, (err) => {
  if (err) {
    console.error(`发送失败:`, err);
    // UDP 不保证送达，依赖重试机制
  }
});
```

**处理策略**：
- 记录错误日志
- 依赖重试机制自动恢复
- 超时后通知用户

#### 2. 文件系统错误

**文件不存在**：
```typescript
if (!fs.existsSync(filePath)) {
  console.error(`文件不存在: ${filePath}`);
  vscode.window.showErrorMessage(`文件不存在: ${filePath}`);
  return;
}
```

**磁盘空间不足**：
```typescript
try {
  fs.writeSync(fd, buffer, ...);
} catch (error) {
  console.error('写入失败:', error);
  vscode.window.showErrorMessage('磁盘空间不足或文件写入失败');
  cleanup();
}
```

**权限错误**：
```typescript
try {
  const fd = fs.openSync(filePath, 'r');
} catch (error) {
  console.error('无法打开文件:', error);
  vscode.window.showErrorMessage('文件权限不足');
  return;
}
```

#### 3. 协议错误

**消息格式错误**：
```typescript
try {
  const payload = JSON.parse(text);
} catch (err) {
  if (err instanceof SyntaxError) {
    // 忽略非 JSON 消息
    return;
  }
  throw err;
}
```

**字段缺失**：
```typescript
if (!data.chunk || typeof data.chunk.index !== 'number') {
  console.error('chunk消息字段不完整');
  return;
}
```

**会话不存在**：
```typescript
const session = fileSendSessions.get(sessionId);
if (!session) {
  console.error(`未找到发送会话：${sessionId}`);
  return;
}
```

#### 4. 传输错误

**块缺失**：
```typescript
const missingChunks = [];
for (let i = 0; i < totalChunks; i++) {
  if (!receivedChunks.has(i)) {
    missingChunks.push(i);
  }
}

if (missingChunks.length > 0) {
  if (resendAttempts < 3) {
    // 请求补发
    sendResendRequest(sessionId, missingChunks);
  } else {
    // 失败
    showError("传输失败");
  }
}
```

**超时**：
```typescript
if (idleTime > timeoutMs) {
  console.warn(`传输超时: ${sessionId}`);
  cleanup();
  vscode.window.showWarningMessage("文件传输超时");
}
```

### 错误恢复机制

**重试层次**：
```
应用层重试（补发机制）
    ↓
消息层重试（MessageRetryManager）
    ↓
超时清理（Session Timeout）
    ↓
用户通知
```

---

## 性能优化

### 1. 块大小选择

**当前设置**：1024 字节

**考虑因素**：
- UDP MTU 限制（通常 1500 字节）
- JSON 编码开销（约 30-40%）
- 避免 IP 分片

**计算**：
```
块大小: 1024 字节
Base64 编码: 1024 * 4/3 ≈ 1365 字节
JSON 元数据: ~200 字节
总大小: ~1565 字节
```

**优化方向**：
- 可以增大到 8192 字节（使用二进制协议）
- 自适应块大小（根据网络状况）

### 2. 并发控制

**当前实现**：顺序发送
```typescript
for (let i = 0; i < chunkCount; i++) {
  sendWithRetry({ chunk: i });
}
```

**优化方向**：滑动窗口
```typescript
const windowSize = 10;
const inFlight = new Set();

while (sentCount < chunkCount) {
  while (inFlight.size < windowSize && sentCount < chunkCount) {
    sendChunk(sentCount++);
  }
  await waitForAck();
}
```

### 3. 内存优化

**当前实现**：
- 使用 Buffer 而非字符串
- 及时关闭文件句柄
- 使用 Set 存储块索引（内存高效）

**内存占用估算**：
```
发送会话: ~100 字节 + Set(chunkCount * 8)
接收会话: ~200 字节 + Set(chunkCount * 8)

示例（100MB 文件）:
chunkCount = 102400
Set 内存 ≈ 819KB
总计 ≈ 1MB / 会话
```

### 4. 持久化优化

**批量写入**：
```typescript
// 每10个块保存一次
if (receivedChunks.size % 10 === 0) {
  savePersistenceData(session);
}
```

**异步写入**：
```typescript
// 使用异步 I/O 避免阻塞
setImmediate(() => {
  fs.writeFileSync(persistenceFile, JSON.stringify(data));
});
```

### 5. 网络优化

**重试间隔**：5秒
- 足够长避免网络拥塞
- 足够短保证响应性

**批量确认**（未实现）：
```typescript
// 可以10个块确认一次
if (receivedChunks.size % 10 === 0) {
  sendBatchAck(sessionId, receivedChunks);
}
```

---

## 安全性考虑

### 1. 路径安全

**问题**：路径遍历攻击
```
恶意路径: "../../../etc/passwd"
```

**防护**：
```typescript
private getSafeRelativePath(filePath: string): string {
  const parsed = path.parse(filePath);
  let relativePath = filePath;
  if (parsed.root) {
    relativePath = path.relative(parsed.root, filePath);
  }
  return relativePath;
}
```

**存储隔离**：
```
所有文件存储在:
{globalStorageUri}/{senderIp}_{senderPort}/{safePath}
```

### 2. 消息验证

**发送方验证**：
```typescript
const decoded = Buffer.from(from, 'base64').toString('utf8');
const parts = decoded.split('-');
const username = parts[0];
const [ip, port] = parts[1].split(':');
```

**字段验证**：
```typescript
// 必填字段检查
if (!data.chunk || typeof data.chunk.index !== 'number') {
  console.error('字段验证失败');
  return;
}

// 类型检查
if (typeof payload.request !== 'boolean') {
  return;
}
```

### 3. 资源限制

**会话数量限制**（建议）：
```typescript
const MAX_ACTIVE_TRANSFERS = 10;

if (activeDownloads.size >= MAX_ACTIVE_TRANSFERS) {
  vscode.window.showErrorMessage('同时传输数量过多');
  return;
}
```

**文件大小限制**（建议）：
```typescript
const MAX_FILE_SIZE = 1024 * 1024 * 1024; // 1GB

if (stat.size > MAX_FILE_SIZE) {
  vscode.window.showErrorMessage('文件过大');
  return;
}
```

### 4. 持久化数据安全

**存储位置**：
```
{globalStorageUri}/.transfer_sessions/
```
- VSCode 的私有存储空间
- 用户无法直接访问
- 仅扩展有权限

**数据清理**：
- 传输完成后立即删除
- 过期会话自动清理（1小时）
- 扩展卸载时清理

### 5. DoS 防护

**问题**：恶意发送大量消息

**防护措施**：
1. **会话超时**：自动清理不活跃会话
2. **重试限制**：最多3次补发请求
3. **消息忽略**：已取消会话的消息直接丢弃

**未实现（建议）**：
- IP 白名单/黑名单
- 速率限制
- 消息大小限制

---

## 性能指标

### 理论性能

**传输速率**：
```
块大小: 1KB
块间隔: ~5ms（包括确认）
理论速率: 1KB / 5ms = 200 KB/s = 1.6 Mbps
```

**实际性能**：
```
局域网: 50-100 KB/s
广域网: 取决于网络延迟和丢包率
```

### 内存占用

**单个传输会话**：
```
发送会话: ~100 字节 + Set 开销
接收会话: ~200 字节 + Set 开销
持久化数据: ~1-5 KB

100MB 文件:
- chunkCount = 102400
- Set 内存 ≈ 819 KB
- 总计 ≈ 1 MB / 会话
```

### 磁盘占用

**持久化数据**：
```json
// 示例: 100MB 文件，接收50MB
{
  "sessionId": "...",
  "receivedChunks": [0,1,2,...,51200],  // 51200个整数
  ...
}

文件大小: ~500 KB - 1 MB
```

### CPU 占用

**主要开销**：
- JSON 序列化/反序列化
- Buffer 编码/解码
- 文件 I/O

**优化**：
- 使用 V8 的内置 JSON 方法（已优化）
- Buffer 操作（C++ 实现，高效）
- 异步 I/O 避免阻塞

---

## 配置参数

### 用户可配置

**VSCode 设置**：
```json
{
  "lnim.retryInterval": 5000,    // 重试间隔（毫秒）
  "lnim.maxRetries": -1,         // 最大重试次数（-1=无限）
  "lnim.port": 18080             // 监听端口
}
```

### 内部常量

```typescript
// ChatFileService
private readonly chunkSize: number = 1024;
private readonly persistenceDir: string;

// ChatMessageService
private readonly chunkSize: number = 1024;

// MessageRetryManager
private readonly retryInterval: number = 5000;
private readonly maxRetries: number = -1;

// 超时配置
const sessionTimeout = {
  receive: {
    base: 60000,           // 60秒
    perMB: 30000,          // 每MB 30秒
    max: 30 * 60 * 1000    // 最多30分钟
  },
  send: {
    base: 5 * 60 * 1000,   // 5分钟
    perMB: 60 * 1000,      // 每MB 1分钟
    max: 30 * 60 * 1000    // 最多30分钟
  }
};

// 补发配置
const MAX_RESEND_ATTEMPTS = 3;

// 持久化配置
const PERSISTENCE_INTERVAL = 10;  // 每10个块
const SESSION_EXPIRY = 60 * 60 * 1000;  // 1小时
```

---

## 故障排除

### 常见问题

#### 1. 文件传输失败

**症状**：显示"缺失N个数据块"

**可能原因**：
- 网络不稳定，丢包严重
- 防火墙阻止 UDP 流量
- 对方已离线

**排查步骤**：
1. 检查网络连接
2. 尝试发送 LINK 消息测试连通性
3. 查看控制台日志
4. 检查防火墙设置

#### 2. 传输超时

**症状**：显示"传输超时"

**可能原因**：
- 网络中断
- 对方程序崩溃
- 文件过大，超时时间不足

**排查步骤**：
1. 检查网络状态
2. 确认对方在线
3. 查看日志中的空闲时间
4. 考虑增加超时时间

#### 3. 文件损坏

**症状**：文件接收完成但无法打开

**可能原因**：
- 块顺序错误（不应发生）
- 块大小错误
- 编码问题

**排查步骤**：
1. 检查日志中的块信息
2. 对比文件大小
3. 检查持久化数据
4. 重新传输

### 调试技巧

**启用详细日志**：
```typescript
// 在 chat_message_service.ts 中
console.log('[接收]', msg);
console.log('[发送]', outMsg);
```

**查看会话状态**：
```typescript
// 添加调试命令
vscode.commands.registerCommand('lnim.debugSessions', () => {
  console.log('Active Downloads:', activeDownloads);
  console.log('Send Sessions:', fileSendSessions);
});
```

**检查持久化数据**：
```bash
# 查看持久化目录
ls -la ~/.config/Code/User/globalStorage/your-extension/.transfer_sessions/

# 查看会话数据
cat ~/.config/Code/User/globalStorage/your-extension/.transfer_sessions/{sessionId}.json
```

---

## 未来改进方向

### 1. 断点续传

**实现思路**：
- 启动时恢复未完成传输
- 请求缺失的块
- 从中断点继续

### 2. 多路复用

**实现思路**：
- 支持同时传输多个文件
- 使用队列管理
- 优先级控制

### 3. 压缩传输

**实现思路**：
- 块级压缩（gzip/brotli）
- 根据文件类型选择
- 平衡 CPU 和网络

### 4. 加密传输

**实现思路**：
- 端到端加密（AES）
- 密钥交换（ECDH）
- 消息认证（HMAC）

### 5. 带宽控制

**实现思路**：
- 限制发送速率
- 避免网络拥塞
- 用户可配置

### 6. 传输统计

**实现思路**：
- 记录传输历史
- 显示速率、成功率
- 生成报告

---

## 总结

本文档详细描述了 VSCode-LNIM 扩展的通信机制，包括：

✅ **基于 UDP 的自定义协议**
✅ **完善的重试机制**
✅ **可靠的文件传输**
✅ **智能的补发机制**
✅ **完整的会话管理**
✅ **健壮的错误处理**

该通信机制在 **简单性、可靠性和性能** 之间取得了良好的平衡，适用于局域网内的文件传输场景。

---

## 参考资料

- UDP 协议: RFC 768
- JSON 格式: RFC 8259
- Base64 编码: RFC 4648
- UUID 规范: RFC 4122
- Node.js dgram 文档
- VSCode 扩展开发文档

---

**文档版本**: 1.0
**最后更新**: 2026-01-20
**维护者**: VSCode-LNIM 开发团队

